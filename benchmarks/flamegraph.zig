const std = @import("std");
const zbench = @import("zbench");
const zflame = @import("zflame");

const allocator = std.heap.page_allocator;

// Test data file path (matching inferno structure)
const TEST_DATA_COLLAPSED = "tests/data/collapse-perf/results/example-perf-stacks-collapsed.txt";

// Helper function to read test data file
fn read_test_file(file_path: []const u8, bench_allocator: std.mem.Allocator) ![]u8 {
    const file = std.fs.cwd().openFile(file_path, .{}) catch |err| switch (err) {
        error.FileNotFound => {
            std.debug.print("Test data file not found: {s}\n", .{file_path});
            return error.TestDataNotFound;
        },
        else => return err,
    };
    defer file.close();

    const file_size = try file.getEndPos();
    const contents = try bench_allocator.alloc(u8, file_size);
    _ = try file.readAll(contents);
    return contents;
}

// Parse collapsed stacks from text data
fn parse_collapsed_stacks(data: []const u8, bench_allocator: std.mem.Allocator) ![]zflame.collapse.CollapsedStack {
    var stacks = std.ArrayList(zflame.collapse.CollapsedStack).init(bench_allocator);
    defer stacks.deinit();

    var lines = std.mem.splitScalar(u8, data, '\n');
    while (lines.next()) |line| {
        const trimmed = std.mem.trim(u8, line, " \t\r\n");
        if (trimmed.len == 0) continue;

        // Find the last space to separate stack from count
        if (std.mem.lastIndexOfScalar(u8, trimmed, ' ')) |last_space| {
            const stack_part = trimmed[0..last_space];
            const count_part = trimmed[last_space + 1 ..];

            if (std.fmt.parseInt(u64, count_part, 10)) |count| {
                const owned_stack = try bench_allocator.dupe(u8, stack_part);
                try stacks.append(.{ .stack = owned_stack, .count = count });
            } else |_| {
                // Skip lines with invalid counts
                continue;
            }
        }
    }

    return stacks.toOwnedSlice();
}

// Benchmark standard flamegraph generation (matching inferno's flamegraph benchmark)
fn bench_flamegraph_standard(bench_allocator: std.mem.Allocator) void {
    const data = read_test_file(TEST_DATA_COLLAPSED, bench_allocator) catch |err| switch (err) {
        error.TestDataNotFound => {
            // Skip benchmark if test data not available
            return;
        },
        else => return,
    };
    defer bench_allocator.free(data);

    const collapsed_stacks = parse_collapsed_stacks(data, bench_allocator) catch return;
    defer {
        for (collapsed_stacks) |stack| {
            bench_allocator.free(stack.stack);
        }
        bench_allocator.free(collapsed_stacks);
    }

    const options = zflame.flamegraph.Options{
        .title = "Benchmark Flame Graph",
        .subtitle = "Generated by zBench",
    };

    var generator = zflame.flamegraph.Generator.init(options);
    var output_buffer: [1024 * 1024]u8 = undefined; // 1MB stack buffer
    var output_stream = std.io.fixedBufferStream(&output_buffer);

    generator.generate_from_collapsed(collapsed_stacks, output_stream.writer()) catch return;
}

// Benchmark flamegraph generation with inverted direction (icicle)
fn bench_flamegraph_inverted(bench_allocator: std.mem.Allocator) void {
    const data = read_test_file(TEST_DATA_COLLAPSED, bench_allocator) catch return;
    defer bench_allocator.free(data);

    const collapsed_stacks = parse_collapsed_stacks(data, bench_allocator) catch return;
    defer {
        for (collapsed_stacks) |stack| {
            bench_allocator.free(stack.stack);
        }
        bench_allocator.free(collapsed_stacks);
    }

    const options = zflame.flamegraph.Options{
        .title = "Benchmark Icicle Graph",
        .subtitle = "Generated by zBench",
        .direction = .inverted,
    };

    var generator = zflame.flamegraph.Generator.init(options);
    var output_buffer: [1024 * 1024]u8 = undefined; // 1MB stack buffer
    var output_stream = std.io.fixedBufferStream(&output_buffer);

    generator.generate_from_collapsed(collapsed_stacks, output_stream.writer()) catch return;
}

// Benchmark flamegraph generation with custom color palette
fn bench_flamegraph_custom_colors(bench_allocator: std.mem.Allocator) void {
    const data = read_test_file(TEST_DATA_COLLAPSED, bench_allocator) catch return;
    defer bench_allocator.free(data);

    const collapsed_stacks = parse_collapsed_stacks(data, bench_allocator) catch return;
    defer {
        for (collapsed_stacks) |stack| {
            bench_allocator.free(stack.stack);
        }
        bench_allocator.free(collapsed_stacks);
    }

    const options = zflame.flamegraph.Options{
        .title = "Benchmark Flame Graph (Java Colors)",
        .subtitle = "Generated by zBench",
        .palette = .{ .multi = .java },
    };

    var generator = zflame.flamegraph.Generator.init(options);
    var output_buffer: [1024 * 1024]u8 = undefined; // 1MB stack buffer
    var output_stream = std.io.fixedBufferStream(&output_buffer);

    generator.generate_from_collapsed(collapsed_stacks, output_stream.writer()) catch return;
}

// Benchmark flamegraph generation with large width
fn bench_flamegraph_large_width(bench_allocator: std.mem.Allocator) void {
    const data = read_test_file(TEST_DATA_COLLAPSED, bench_allocator) catch return;
    defer bench_allocator.free(data);

    const collapsed_stacks = parse_collapsed_stacks(data, bench_allocator) catch return;
    defer {
        for (collapsed_stacks) |stack| {
            bench_allocator.free(stack.stack);
        }
        bench_allocator.free(collapsed_stacks);
    }

    const options = zflame.flamegraph.Options{
        .title = "Benchmark Flame Graph (Large)",
        .subtitle = "Generated by zBench",
        .image_width = 2400, // Double the default width
    };

    var generator = zflame.flamegraph.Generator.init(options);
    var output_buffer: [1024 * 1024]u8 = undefined; // 1MB stack buffer
    var output_stream = std.io.fixedBufferStream(&output_buffer);

    generator.generate_from_collapsed(collapsed_stacks, output_stream.writer()) catch return;
}

pub fn main() !void {
    var benchmark = zbench.Benchmark.init(allocator, .{});
    defer benchmark.deinit();

    try benchmark.add("flamegraph_standard", bench_flamegraph_standard, .{});
    try benchmark.add("flamegraph_inverted", bench_flamegraph_inverted, .{});
    try benchmark.add("flamegraph_custom_colors", bench_flamegraph_custom_colors, .{});
    try benchmark.add("flamegraph_large_width", bench_flamegraph_large_width, .{});

    try benchmark.run(std.io.getStdOut().writer());
}
